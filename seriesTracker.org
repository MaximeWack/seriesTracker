#+title: seriesTracker
#+author: Maxime Wack
#+property: header-args :results silent

* Preamble

#+begin_src elisp
;;; package --- Summary
;; Package-Requires: ((dash "2.12.1"))
;;; Commentary:
;;; Code:
#+end_src

* Requirements

~url~ is needed to connect to the API and ~json~ to parse the response.
~dash~ is used to simplify writing.


#+begin_src elisp
(require 'url)
(require 'json)
(require 'dash)
#+end_src

* tvdb API

API layer to communicate with theTVdbAPI.
This is mainly a /GET/ API, with one /POST/ method for authentication.
The results are returned in JSON, almost everytime in the ~data~ element.
Large queries require pagination with information in the ~links~ element.
~/refresh_token~ returns the token in the ~token~ element.

** getJSON

TheTVdbAPI answers in JSON.
Parse the JSON in the url-buffer response with ~json-read-object~.

#+begin_src elisp
(defun getJSON (url-buffer)
  "Parse the JSON in the URL-BUFFER returned by url."

  (with-current-buffer url-buffer
    (goto-char (point-max))
    (move-beginning-of-line 1)
    (json-read-object)))
#+end_src

** login

TheTVdbAPI requires login to access.
This is the only /POST/ call in the API and it provides the token needed for all other operations.
The login needs a ~username~, an ~apikey~, and a ~userkey~.
Parse the response using ~getJSON~, and return the ~token~ element.

#+begin_src elisp
(defun login (username apikey userkey)
  "Login using USERNAME, APIKEY and USERKEY.
Return the token"

  (->> (let ((url-request-method "POST")
            (url-request-extra-headers '(("Content-Type" . "application/json")
                                         ("Accept" . "application/json")))
            (url-request-data (concat "{\"apikey\": \"" apikey "\", \"userkey\": \"" userkey "\", \"username\": \"" username "\" }"))
            (url-show-status nil))
        (url-retrieve-synchronously "https://api.thetvdb.com/login" t))
      getJSON
      (alist-get 'token)))
#+end_src

Save the token in a declared variable

#+begin_src elisp
(defvar tvdb--token
  nil
  "Auth token")
#+end_src

For example:

#+begin_src elisp
(setq tvdb--token (login ""
                        ""
                        ""))
#+end_src

** Queries

elisp functions to call API endpoints.

Requirements:
- search series
- get episode list with airing times
- get updated series

*** Helpers

Helper functions to work with the queries and their results.

**** tvdb

All calls to theTVdbAPI are /GET/ calls using the token and parameters.
Call the API /GET/ endpoints with the Authorization ~token~ and the ~params~ as a string.
Return the whole JSON response.

#+begin_src elisp
(defun _tvdb (token params)
  (getJSON
   (let* ((url-request-method "GET")
          (bearer (concat "Bearer " token))
          (url-request-extra-headers `(("Accept" . "application/json")
                                       ("Authorization" . ,bearer)))
          (url-show-status nil))
     (url-retrieve-synchronously (concat "https://api.thetvdb.com" params)))))
#+end_src

~refresh_token~ is the only call that doesn't require parameters nor return its result in the ~data~ element.
Make the default call to ~tvdb~ when ~params~ is /nil/ to ~refresh_token~, return the ~data~ element otherwise.
~params~ is concatenated as a string.

#+begin_src elisp
(defun tvdb (token &rest params)
  "Generic function to query tvdbapi.

Needs a TOKEN to work. The TOKEN can be obtained using the LOGIN function.
If no PARAMS are given, call refresh_token, else concatenate all params and call the API.
Returns the data element of the parsed JSON response."

  (if params
      (alist-get 'data
                 (_tvdb token (apply 'concat params)))
    (alist-get 'token
               (_tvdb token "/refresh_token"))))
#+end_src

For example, refreshing the token:

#+begin_src elisp
(tvdb tvdb--token)
#+end_src

**** alist-select

Each series and episode is represented as an alist.
Select a list of elements from an alist.

#+begin_src elisp
(defun alist-select (fields alist)
  "Keep only FIELDS in ALIST by constructing a new alist containing only these elements."

  (->> fields
       reverse
       (--reduce-from (acons it (alist-get it alist) acc)
                     nil)))
#+end_src

For example:

#+begin_src elisp
(alist-select
 '(a c)
 '((a . 1)
   (b . "b")
   (c . c)))
#+end_src

**** array-select

Series and episodes lists are represented as arrays of alists.
Select a list of elements from each alist in an array.

#+begin_src elisp
(defun array-select (fields array)
  "Keep only FIELDS in every alist in the ARRAY. "

  (--map (alist-select fields it) array))
#+end_src

For example:

#+begin_src elisp
(array-select '(a c)
              '(((a . 1) (b . "b") (c . c))
                ((a . 3) (b . "a") (c . d))))
#+end_src

**** array-pull

Same elements in each alist in a array consitute a column.
Extract a column from an array.

#+begin_src elisp
(defun array-pull (field array)
  "Keep only FIELD in every alist in the ARRAY and flatten."

  (--map (alist-get field it) array))
#+end_src

Example:

#+begin_src elisp
(array-pull 'a
            '(((a . 1) (b . 2)) ((a . 3) (b . 4))))
#+end_src

**** array-mutate

Apply a function to all values of a column in an array.

#+begin_src elisp
(defun array-mutate (fun elem array)
  "Execute FUN on ELEM of all the alists in ARRAY"

  (-map (lambda (item)
          (setf (alist-get elem item)
                (eval `(,fun ,(alist-get elem item))))
          item)
        array))
#+end_src

Example:

#+begin_src elisp
(array-mutate '1+ 'a
              '(((a . 1) (b . 2)) ((a . 3) (b . 4))))
#+end_src

**** epoch/datestring
Convert between epochs and datestrings.
fromTime in ~update~ needs to be in epoch format.
~update~ returns lastUpdated as epoch.
However, firstAired for series and episodes is a date.

#+begin_src elisp
(defun epoch-to-date (epoch)
  "Convert EPOCH to a date."

  (->> epoch
      (time-add 0)
      (format-time-string "%Y-%m-%d")))
#+end_src

#+begin_src elisp
(defun epoch-to-datetime (epoch)
  "Convert EPOCH to a datetime."

  (->> epoch
      (time-add 0)
      (format-time-string "%Y-%m-%d %H:%M:%S")))
#+end_src

Example:

#+begin_src elisp
(epoch-to-date 1577833200)
(epoch-to-datetime 1577833200)
#+end_src

#+begin_src elisp
(defun datetime-to-epoch (datetime)
  "Convert DATETIME to an epoch."

  (->> datetime
      date-to-time
      (format-time-string "%s")
      (string-to-number)))
#+end_src

#+begin_src elisp
(defun date-to-epoch (date)
  "Convert DATE to an epoch."

  (->> (concat date " 00:00:00")
      datetime-to-epoch))
#+end_src

#+begin_src elisp
(defun current-epoch ()
    "Get (current-time) as an epoch."

    (string-to-number (format-time-string "%s" (current-time))))
#+end_src

Example:

#+begin_src elisp
(date-to-epoch "2020-01-01")
(datetime-to-epoch "2020-01-01 00:00")
(current-epoch)
#+end_src

*** search

Search for a series by name.

Keep elements:
- id :: unique id
- seriesName :: series name
- firstAired :: date first aired
- status :: Ended | Continuing | Upcoming
- network :: network
- overview :: description

#+begin_src elisp
(defun search (token seriesName)
  "Search for SERIESNAME.
Needs a TOKEN to work. The TOKEN can be obtained using the LOGIN function."

  (->> seriesName
      (tvdb token "/search/series?name=")
      (array-select '(id
                      seriesName
                      firstAired
                      status
                      network
                      overview))))
#+end_src

For example:

#+begin_src elisp
(setq series-list (search tvdb--token "Game of Thrones"))
#+end_src

*** series

Get a series detailed information.

Keep elements:
- id :: unique id
- seriesName :: series name
- status :: Ended | Continuing | Upcoming

#+begin_src elisp
(defun series (token id)
  "Get informations about a specific series ID.
Needs a TOKEN to work. The TOKEN can be obtained using the LOGIN function."

  (->> id
      int-to-string
      (tvdb token "/series/")
      (alist-select '(id
                      seriesName
                      status))))
#+end_src

For example:

#+begin_src elisp
(setq serie (series tvdb--token 121361))
#+end_src

*** series/episodes

Get all episodes of a series.

Keep elements:
- id :: episode id
- absoluteNumber :: total number
- airedSeason :: season number
- airedEpisodeNumber :: episode number
- episodeName :: name of the episode
- firstAired :: date of airing
- siteRating :: rating for this episode
- siteRatingCount :: votes for this episode


The episode list is paginated.
Recursively append the results in the ~next~ page.

#+begin_src elisp
(defun series/episodesPage (token id page acc)
  "Get the whole episode list of show ID recursively.

Needs a TOKEN to work. The TOKEN can be obtained using the LOGIN function.
PAGE is the current queried page and ACC the accumulator."

  (let* ((query (_tvdb token (concat "/series/" (int-to-string id) "/episodes?page=" (int-to-string page))))
         (next (->> query
                    (alist-get 'links)
                    (alist-get 'next)))
         (data (->> query
                    (alist-get 'data)
                    (array-select '(id
                                    absoluteNumber
                                    airedSeason
                                    airedEpisodeNumber
                                    episodeName
                                    firstAired
                                    siteRating
                                    siteRatingCount)))))
    (if next
        (series/episodesPage token id next (append acc data))
      (append acc data))))
#+end_src

The results contain special episodes and are unsorted.
Filter out episodes with ~airedSeason~ = 0, and sort according to ~absoluteNumber~.

#+begin_src elisp
(defun series/episodes (token id)
  "Get all episodes for a specific series ID.
Needs a TOKEN to work. The TOKEN can be obtained using the LOGIN function."

  (->> (series/episodesPage token id 1 nil)
       (--filter (> (alist-get 'airedSeason it) 0))
       (--sort (< (alist-get 'absoluteNumber it)
                  (alist-get 'absoluteNumber other)))))
#+end_src

For example, all episodes from Game of Thrones:

#+begin_src elisp
(setq episodes (series/episodes tvdb--token 121361))
#+end_src

*** update

Get a list of updated series.
The API only returns data for a period of *one week* after ~fromTime~.
~lastUpdated~ is given as an epoch.

Query one week of updates and convert ~lastUpdated~ to a datestring.

#+begin_src elisp
(defun _update (token fromTime)
  "Return an array of series that have changed in the week after FROMTIME.
Needs a TOKEN to work. The TOKEN can be obtained using the LOGIN function."

  (->> fromTime
       (tvdb token "/updated/query?fromTime=")
       (array-mutate 'epoch-to-datetime 'lastUpdated)))
#+end_src

Call ~_update~ for every week from ~fromTime~ to ~(current-time)~.

#+begin_src elisp
(defun update (token fromTime)
  "Return an array of series that have changed since FROMTIME.
Needs a TOKEN to work.  The TOKEN can be obtained using the LOGIN function."
  (->> (number-sequence
        (datetime-to-epoch fromTime)
        (current-epoch)
        (* 3600 24 7))
       (-map 'int-to-string)
       (--map (_update token it))
       (-flatten-n 1)))
#+end_src

For example, the updates in the last hour:

#+begin_src elisp
(setq updates (update tvdb--token (format-time-string "%Y-%m-%d %H:00" (current-time))))
(update tvdb--token "2020-05-01 00:00")
#+end_src

* Internal API

API to manipulate the internal data representation.

Requirements:
- [X] renew token
- [X] search a series
- [X] add series to list of followed series
- [X] remove series from list of followed series
- [X] show list of followed series
- [X] show all episodes of a series in the list
- [ ] mark any watched episode for any followed series
- [ ] mark all episodes up to a given episodes as watched
- [ ] query updates for new episodes
- [X] show a list of upcoming episodes
- [ ] show a list of available episodes to watch

** Data model

Keep track of followed series and watched episodes.
The model is a list of series alists with keys ~id~, ~seriesName~, and ~status~.
Each series alist also contains an ~episodes~ key with a list of episodes alists with keys ~id~, ~absoluteNumber~, ~airedSeason~, ~airedEpisodeNumber~, ~episodeName~, ~firstAired~, ~siteRating~, ~siteRatingCount~
Each episode alist also contains a ~watched~ key.

#+begin_src elisp
(defvar tvdb--data
  nil
  "Internal data containing followed series and episode.

Of the form :

'(((id . seriesId) (props . value) (…) (episodes ((id . episodeId) (watched . t) (props.value) (…))
                                                 ((id . episodeId) (watched . nil) (props.value) (…))))
  ((id . seriesId) (…) (episodes ((id . episodeId) (…))
                                 ((id . episodeId) (…)))))")
#+end_src

** Methods
*** renew token
:PROPERTIES:
:ID:       fa55a6fc-d66b-4c84-ae5f-1dc03fa802d3
:END:

Renew the token.
It should reconnect if token is invalid, and throw an error message if no valid credentials are given.
The token should be renewed prior to any query (or after a certain timeout?)

#+begin_src elisp
(defun tvdb-renew-token ()
  "Renew the token in tvdb--token."

  (setq tvdb--token (tvdb tvdb--token)))
#+end_src

#+begin_src elisp
(tvdb-renew-token)
#+end_src

*** search a series

Search a series by name.

#+begin_src elisp
(defun tvdb-search (seriesName)
  "Search SERIESNAME."

  (search tvdb--token seriesName))
#+end_src

*** add series to list

Add a series to ~tvdb--data~, with its list of episodes.
Adding an already existing list resets the list (ie. all episodes are unwatched).

#+begin_src elisp
(defun tvdb-add (id)
  "Add series with ID to tvdb--data.
Adding an already existing series resets it."

  (setq tvdb--data
        (--> tvdb--data
               (--remove (= id (alist-get 'id it)) it)
               (-snoc it (--> (series tvdb--token id)
                                  (-snoc it `(episodes ,@(series/episodes tvdb--token id))))))))
#+end_src

#+begin_src elisp
(tvdb-add 121361)
#+end_src

*** remove series from list

Remove a series from ~tvdb--data~.

#+begin_src elisp
(defun tvdb-remove (id)
  "Remove series with ID from tvdb--data."

  (setq tvdb--data
        (--remove (= id (alist-get 'id it)) tvdb--data)))
#+end_src

#+begin_src elisp
(tvdb-remove 121361)
#+end_src

*** get list of followed series

Get the list of series in ~tvdb--data~ without episodes.

#+begin_src elisp
(defun tvdb-get-series ()
  "Get followed series."

  (array-select '(id seriesName) tvdb--data))
#+end_src

#+begin_src elisp
(tvdb-get-series)
#+end_src

*** get all episodes of a followed series

Get all episodes of a series in ~tvdb--data~.

#+begin_src elisp
(defun tvdb-get-episodes (id)
  "Get episodes of series with ID."

  (alist-get 'episodes
             (--first (= id (alist-get 'id it)) tvdb--data)))
#+end_src

#+begin_src elisp
(tvdb-get-episodes 264991)
#+end_src

*** watch an episode from a series

Set an episode as watched.

#+begin_src elisp
(defun tvdb-watch (seriesId episodeId)
  "Watch episode EPISODEID in series SERIESID."

  (setq tvdb--data
        (->> tvdb--data
             (--map-when (= seriesId (alist-get 'id it))
                        `((id         . ,(alist-get 'id it))
                          (seriesName . ,(alist-get 'seriesName it))
                          (episodes ,@(--map-when (= episodeId (alist-get 'id it))
                                                 `((id                 . ,(alist-get 'id it))
                                                   (absoluteNumber     . ,(alist-get 'absoluteNumber it))
                                                   (airedSeason        . ,(alist-get 'airedSeason it))
                                                   (airedEpisodeNumber . ,(alist-get 'airedEpisodeNumber it))
                                                   (episodeName        . ,(alist-get 'episodeName it))
                                                   (firstAired         . ,(alist-get 'firstAired it))
                                                   (siteRating         . ,(alist-get 'siteRating it))
                                                   (siteRatingCount    . ,(alist-get 'siteRatingCount it))
                                                   (watched            . t))
                                             (alist-get 'episodes it))))))))

(setq list '(((id . 1) (episodes ((id . 1) (watched . t))
                                 ((id . 2))
                                 ((id . 3))))
             ((id . 2) (episodes ((id . 1) (watched . t))
                                 ((id . 2) (watched . t))))))


#+end_src

*** get list of upcoming episodes

Get list of all unwatched episodes.

#+begin_src elisp
(defun tvdb-upcoming ()
  "List upcoming episodes."

  (->> tvdb--data
       (--map `((id         . ,(alist-get 'id it))
                (seriesName . ,(alist-get 'seriesName it))
                (episodes ,@(--filter (equal nil (alist-get 'watched it))
                                     (alist-get 'episodes it)))))
       (--remove (equal '(nil) (alist-get 'episodes it)))))
#+end_src

#+begin_src elisp
(tvdb-upcoming)
#+end_src

*** get list of episodes to watch

Get list of all unwatched episodes that have already aired.

#+begin_src elisp
(defun tvdb-to-watch ()
  "List of episodes to watch."

  (->> (tvdb-upcoming)
      (--map `((id         . ,(alist-get 'id it))
               (seriesName . ,(alist-get 'seriesName it))
               (episodes ,@(--remove (> (date-to-epoch (alist-get 'firstAired it)) (current-epoch))
                                    (alist-get 'episodes it)))))))
#+end_src

#+begin_src elisp
(tvdb-to-watch)
#+end_src

* Postamble

#+begin_src elisp
(provide 'seriesTracker)

;;; seriesTracker.el ends here
#+end_src
